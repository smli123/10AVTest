package com.sherman.smartplugex.ui.util;

import java.util.ArrayList; 
import java.util.List; 
import java.util.Timer; 
import java.util.TimerTask; 
 
import android.content.Context; 
import android.graphics.Canvas; 
import android.graphics.Paint; 
import android.graphics.Paint.Align; 
import android.graphics.Paint.FontMetricsInt; 
import android.graphics.Paint.Style; 
import android.os.Handler; 
import android.os.Message; 
import android.util.AttributeSet; 
import android.view.MotionEvent; 
import android.view.View; 
 
/** 
 * æ»šåŠ¨é€‰æ‹©å™? 
 * 
 * @author æ— äººæ°? 
 * 
 */ 
public class ShermanPickerView extends View 
{
 
  public static final String TAG = "ThingzdoPickerView"; 
  /** 
   * textä¹‹é—´é—´è·å’ŒminTextSizeä¹‹æ¯” 
   */ 
  public static final float MARGIN_ALPHA = 1.85f;	//2.8f; 
  /** 
   * è‡ªåŠ¨å›æ»šåˆ°ä¸­é—´çš„é€Ÿåº¦ 
   */ 
  public static final float SPEED = 2; 
 
  private List<String> mDataList; 
  /** 
   * é€‰ä¸­çš„ä½ç½®ï¼Œè¿™ä¸ªä½ç½®æ˜¯mDataListçš„ä¸­å¿ƒä½ç½®ï¼Œä¸?ç›´ä¸å? 
   */ 
  private int mCurrentSelected; 
  private Paint mPaint; 
 
  private float mMaxTextSize = 60;	//80; 
  private float mMinTextSize = 30;	//40; 
 
  private float mMaxTextAlpha = 255; 
  private float mMinTextAlpha = 120; 
 
  private int mColorText = 0x333333; 
 
  private int mViewHeight; 
  private int mViewWidth; 
 
  private float mLastDownY; 
  /** 
   * æ»‘åŠ¨çš„è·ç¦? 
   */ 
  private float mMoveLen = 0; 
  private boolean isInit = false; 
  private onSelectListener mSelectListener; 
  private Timer timer; 
  private MyTimerTask mTask; 
 
  Handler updateHandler = new Handler() 
  { 
 
    @Override 
    public void handleMessage(Message msg) 
    { 
      if (Math.abs(mMoveLen) < SPEED) 
      { 
        mMoveLen = 0; 
        if (mTask != null) 
        { 
          mTask.cancel(); 
          mTask = null; 
          performSelect(); 
        } 
      } else 
        // è¿™é‡ŒmMoveLen / Math.abs(mMoveLen)æ˜¯ä¸ºäº†ä¿æœ‰mMoveLençš„æ­£è´Ÿå·ï¼Œä»¥å®ç°ä¸Šæ»šæˆ–ä¸‹æ»? 
        mMoveLen = mMoveLen - mMoveLen / Math.abs(mMoveLen) * SPEED; 
      invalidate(); 
    } 
 
  }; 
 
  public ShermanPickerView(Context context) 
  { 
    super(context); 
    init(); 
  } 
 
  public ShermanPickerView(Context context, AttributeSet attrs) 
  { 
    super(context, attrs); 
    init(); 
  } 
  
  public void setOnSelectListener(onSelectListener listener) 
  { 
    mSelectListener = listener; 
  }
  
  private void performSelect() 
  { 
    if (mSelectListener != null) 
      mSelectListener.onSelect(mDataList.get(mCurrentSelected)); 
  } 
 
  public void setData(List<String> datas) 
  { 
    mDataList = datas; 
    mCurrentSelected = datas.size() / 2; 
    invalidate(); 
  } 

  public void setSelected(int selected) 
  { 
    mCurrentSelected = selected; 
  } 
  
  public int getSelected()
  { 
    return mCurrentSelected; 
  } 
 
  private void moveHeadToTail() 
  { 
    String head = mDataList.get(0); 
    mDataList.remove(0); 
    mDataList.add(head); 
  } 
 
  private void moveTailToHead() 
  { 
    String tail = mDataList.get(mDataList.size() - 1); 
    mDataList.remove(mDataList.size() - 1); 
    mDataList.add(0, tail); 
  } 
 
  @Override 
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 
  { 
    super.onMeasure(widthMeasureSpec, heightMeasureSpec); 
    mViewHeight = getMeasuredHeight(); 
    mViewWidth = getMeasuredWidth(); 
    // æŒ‰ç…§Viewçš„é«˜åº¦è®¡ç®—å­—ä½“å¤§å°? 
    mMaxTextSize = mViewHeight / 4.0f; 
    mMinTextSize = mMaxTextSize / 2f; 
    isInit = true; 
    invalidate(); 
  } 
 
  private void init() 
  { 
    timer = new Timer(); 
    mDataList = new ArrayList<String>(); 
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); 
    mPaint.setStyle(Style.FILL); 
    mPaint.setTextAlign(Align.CENTER); 
    mPaint.setColor(mColorText); 
  } 
 
  @Override 
  protected void onDraw(Canvas canvas) 
  { 
    super.onDraw(canvas); 
    // æ ¹æ®indexç»˜åˆ¶view 
    if (isInit) 
      drawData(canvas); 
  } 
 
  private void drawData(Canvas canvas) 
  { 
    // å…ˆç»˜åˆ¶é?‰ä¸­çš„textå†å¾€ä¸Šå¾€ä¸‹ç»˜åˆ¶å…¶ä½™çš„text 
    float scale = parabola(mViewHeight / 4.0f, mMoveLen); 
    float size = (mMaxTextSize - mMinTextSize) * scale + mMinTextSize; 
    mPaint.setTextSize(size); 
    mPaint.setAlpha((int) ((mMaxTextAlpha - mMinTextAlpha) * scale + mMinTextAlpha)); 
    // textå±…ä¸­ç»˜åˆ¶ï¼Œæ³¨æ„baselineçš„è®¡ç®—æ‰èƒ½è¾¾åˆ°å±…ä¸­ï¼Œyå€¼æ˜¯textä¸­å¿ƒåæ ‡ 
    float x = (float) (mViewWidth / 2.0); 
    float y = (float) (mViewHeight / 2.0 + mMoveLen); 
    FontMetricsInt fmi = mPaint.getFontMetricsInt(); 
    float baseline = (float) (y - (fmi.bottom / 2.0 + fmi.top / 2.0)); 
 
    canvas.drawText(mDataList.get(mCurrentSelected), x, baseline, mPaint); 
    // ç»˜åˆ¶ä¸Šæ–¹data 
    for (int i = 1; (mCurrentSelected - i) >= 0; i++) 
    { 
      drawOtherText(canvas, i, -1); 
    } 
    // ç»˜åˆ¶ä¸‹æ–¹data 
    for (int i = 1; (mCurrentSelected + i) < mDataList.size(); i++) 
    { 
      drawOtherText(canvas, i, 1); 
    } 
 
  } 
 
  /** 
   * @param canvas 
   * @param position 
   *      è·ç¦»mCurrentSelectedçš„å·®å€? 
   * @param type 
   *      1è¡¨ç¤ºå‘ä¸‹ç»˜åˆ¶ï¼?-1è¡¨ç¤ºå‘ä¸Šç»˜åˆ¶ 
   */ 
  private void drawOtherText(Canvas canvas, int position, int type) 
  { 
    float d = (float) (MARGIN_ALPHA * mMinTextSize * position + type 
        * mMoveLen); 
    float scale = parabola(mViewHeight / 4.0f, d); 
    float size = (mMaxTextSize - mMinTextSize) * scale + mMinTextSize; 
    mPaint.setTextSize(size); 
    mPaint.setAlpha((int) ((mMaxTextAlpha - mMinTextAlpha) * scale + mMinTextAlpha)); 
    float y = (float) (mViewHeight / 2.0 + type * d); 
    FontMetricsInt fmi = mPaint.getFontMetricsInt(); 
    float baseline = (float) (y - (fmi.bottom / 2.0 + fmi.top / 2.0)); 
    canvas.drawText(mDataList.get(mCurrentSelected + type * position), 
        (float) (mViewWidth / 2.0), baseline, mPaint); 
  } 
 
  /** 
   * æŠ›ç‰©çº? 
   * 
   * @param zero 
   *      é›¶ç‚¹åæ ‡ 
   * @param x 
   *      åç§»é‡? 
   * @return scale 
   */ 
  private float parabola(float zero, float x) 
  { 
    float f = (float) (1 - Math.pow(x / zero, 2)); 
    return f < 0 ? 0 : f; 
  } 
 
  @Override 
  public boolean onTouchEvent(MotionEvent event) 
  { 
    switch (event.getActionMasked()) 
    { 
    case MotionEvent.ACTION_DOWN: 
      doDown(event); 
      break; 
    case MotionEvent.ACTION_MOVE: 
      doMove(event); 
      break; 
    case MotionEvent.ACTION_UP: 
      doUp(event); 
      break; 
    } 
    return true; 
  } 
 
  private void doDown(MotionEvent event) 
  { 
    if (mTask != null) 
    { 
      mTask.cancel(); 
      mTask = null; 
    } 
    mLastDownY = event.getY(); 
  } 
 
  private void doMove(MotionEvent event) 
  { 
 
    mMoveLen += (event.getY() - mLastDownY); 
 
    if (mMoveLen > MARGIN_ALPHA * mMinTextSize / 2) 
    { 
      // å¾?ä¸‹æ»‘è¶…è¿‡ç¦»å¼€è·ç¦» 
      moveTailToHead(); 
      mMoveLen = mMoveLen - MARGIN_ALPHA * mMinTextSize; 
    } else if (mMoveLen < -MARGIN_ALPHA * mMinTextSize / 2) 
    { 
      // å¾?ä¸Šæ»‘è¶…è¿‡ç¦»å¼€è·ç¦» 
      moveHeadToTail(); 
      mMoveLen = mMoveLen + MARGIN_ALPHA * mMinTextSize; 
    } 
 
    mLastDownY = event.getY(); 
    invalidate(); 
  } 
 
  private void doUp(MotionEvent event) 
  { 
    // æŠ¬èµ·æ‰‹åmCurrentSelectedçš„ä½ç½®ç”±å½“å‰ä½ç½®moveåˆ°ä¸­é—´é?‰ä¸­ä½ç½® 
    if (Math.abs(mMoveLen) < 0.0001) 
    { 
      mMoveLen = 0; 
      return; 
    } 
    if (mTask != null) 
    { 
      mTask.cancel(); 
      mTask = null; 
    } 
    mTask = new MyTimerTask(updateHandler); 
    timer.schedule(mTask, 0, 10); 
  } 
 
  class MyTimerTask extends TimerTask 
  { 
    Handler handler; 
 
    public MyTimerTask(Handler handler) 
    { 
      this.handler = handler; 
    } 
 
    @Override 
    public void run() 
    { 
      handler.sendMessage(handler.obtainMessage()); 
    } 
 
  } 
 
  public interface onSelectListener 
  { 
    void onSelect(String text); 
  } 
}